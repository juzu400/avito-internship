# avito-internship

Уважаемая команда Авито!
Спасибо за возможность поучаствовать в отборе на стажировку, ниже представлено описание моего решения тестового задания.

## Стек

- Язык: **Go (Golang)**
- База данных: **PostgreSQL**
- Все поднимается в **Docker**
- HTTP-слой: **chi**
- Работа с БД: **pgx**
- Логирование: **slog**
- Тестирование: `testing`, `httptest`, моки через `gomock`, нагрузочное через `grafana k6`.
- Линтер: **golangci-lint** version 2.

## Запуск

В проекте используется `Makefile` для упрощения команд.
- Запуск всего стека (Postgres + сервис): `make docker-up`
- Остановка и очистка данных: `make docker-down`
- Локальный запуск сервиса: `make run`
- Сборка бинарника: `make build`
- Тесты: `make test`
- Запуск линтера: `make lint`
- Обновить зависимости: `make tidy`
- Gomock-моки для репозиториев делаются в `internal/repository/repository.go`.

По умолчанию сервис слушает `:8080`.

## Реализовано

- Реализованы все требования основного задания:
    - команды: создание, получение по названию;
    - пользователи: изменение статуса активности, получение списка PR, где пользователь ревьюер;
    - pull request’ы: создание с автоподбором ревьюеров, merge (идемпотентный), переназначение ревьюера.
- Добавлен логгер для бизнес-событий и ошибок.
- Настроены миграции БД: при запуске приложения автоматически выполняются все `.sql`-миграции из каталога `migrations/`, отдельные команды для этого не требуются.
- Написаны юнит-тесты для сервисов и HTTP-хэндлеров с использованием `gomock` и `httptest`.
- В коде добавлены небольшие фрагменты документации на английском языке, поясняющие поведение ключевых методов (репозитории, сервисы, хэндлеры).
- Из доп. требований:
    - настроен и вынесен в `Makefile` запуск линтера (`golangci-lint run ./...`). 
    - добавлены эндпоинты со статистикой:
        - `GET /users/stats` — статистика по количеству PR, в которых пользователи являются ревьюером.;
        - `GET /pullRequests/stats` — статистика по pull request’ам по числу ревьюеров.
    - проведено нагрузочное тестирование с помощью `grafana k6`:
       - чтение статистики (`GET /users/stats`, `GET /pullRequests/stats`) — ~362 req/s, средняя латентность ~4.9 ms, `http_req_failed = 0%`;
       - создание PR (`POST /pullRequest/create`) — ~93 req/s, средняя латентность ~6.9 ms, `http_req_failed = 0%`.
    - интеграционное (E2E) тестирование:
       - добавлен тест `TestE2E_CreatePRAndStats` в пакете `test/e2e`;
       - тест поднимает HTTP-сервер с реальными репозиториями и отдельной тестовой БД PostgreSQL (`db_test`);
       - сценарий: создание команды и двух пользователей → создание PR → проверка статистики по пользователям (`/users/stats`) и pull request’ам (`/pullRequests/stats`).

## Коротко про поведение и ошибки

Все ошибки возвращаются в едином формате:
```json
{
  "error": {
    "code": "КОД_ОШИБКИ",
    "message": "описание"
  }
}
```
Основные коды ошибок:  
`VALIDATION_ERROR`, `NOT_FOUND`, `TEAM_EXISTS`, `PR_EXISTS`, `PR_MERGED`, `NOT_ASSIGNED`, `NO_CANDIDATE`, `INTERNAL_ERROR`.

Кратко по эндпоинтам:

**POST `/team/add`** — создаёт команду.  
Ответы:  
- `201` — успех, созданная команда; 
- `400` — невалидный JSON / ошибка валидации (`team_name` пустой, пустой `user_id`, дубликат участника, пользователь уже находится в другой команде, команда уже существует);
- `500` — внутренняя ошибка.

**GET `/team/get`** — получить команду по названию.
Параметры передаются через **query**: `?team_name=`.  
Ответы:  
- `200` — успех, полученная команда;  
- `400` — нет `team_name` или ошибка валидации;  
- `404` — `NOT_FOUND`;  
- `500` — внутренняя ошибка.

**POST `/users/setIsActive`** — изменение статуса активности пользователя.  
Ответы:  
- `200` — успех, обновлённый пользователь;  
- `400` — невалидный JSON / пустой `user_id`;  
- `404` — `NOT_FOUND`;  
- `500` — внутренняя ошибка.

**GET `/users/getReview`** — список PR, где пользователь выступает ревьюером.  
Параметры передаются через **query**: `?user_id=`.  
Ответы:  
- `200` — успех, список PR;  
- `400` — нет `user_id` / ошибка валидации;  
- `404` — пользователь не найден;  
- `500` — внутренняя ошибка.

**POST `/pullRequest/create`** — создать PR.  
Логика: создаёт PR, находит команду автора и выбирает до двух активных ревьюеров из команды (кроме автора).  
Ответы:  
- `201` — успех, созданный PR;  
- `400` — невалидный JSON / пустые поля (`pull_request_id`, `pull_request_name`, `author_id`);  
- `404` — автор не найден;  
- `409` — `PR_EXISTS`;  
- `500` — внутренняя ошибка.

**POST `/pullRequest/merge`** — merge PR (идемпотентно).  
Ответы:  
- `200` — успех, PR с обновленным статусом или PR, который уже был в статусе `MERGED`;  
- `400` — невалидный JSON / пустой `pull_request_id`;  
- `404` — PR не найден;  
- `500` — внутренняя ошибка.

**POST `/pullRequest/reassign`** — переназначение ревьюера.   
Ответы:  
- `200` — успех, ревьювер успешно переназначен;  
- `400` — невалидный JSON / ошибочные параметры;  
- `404` — PR или пользователь не найдены;  
- `409` — конфликт: `PR_MERGED` (PR уже смержен), `NOT_ASSIGNED` (старый ревьювер не был назначен на этот PR), `NO_CANDIDATE` (нет кандидатов на замену);  
- `500` — внутренняя ошибка.

**GET `/users/stats`** — статистика назначений ревьюеров по пользователям.  
Ответы:
- `200` — успех, возвращается объект с полем `items`, в котором перечислены **все пользователи** и количество назначений каждого в качестве ревьюера. Пользователи без PR тоже присутствуют, для них `assignments = 0`;
- `500` — внутренняя ошибка.

**GET `/pullRequests/stats`** — статистика по pull request’ам и количеству ревьюеров.  
Ответы:
- `200` — успех, возвращается объект с полем `items`, в котором перечислены **все pull request’ы** и количество назначенных на них ревьюеров. PR без ревьюеров тоже присутствуют, для них `reviewers = 0`;
- `500` — внутренняя ошибка.

---

## Нагрузочное тестирование

Нагрузочное тестирование проводилось с помощью grafana k6 на локальном окружении:

- сервис с бд подняты в докере (`docker-up`);
- в БД заранее созданы пользователи, команда и PR.

### Чтение (статистика)

Сценарий (`load_read.js`):

- 20 виртуальных пользователей (`vus = 20`);
- длительность теста — 30 секунд;
- каждый VU в цикле делает два запроса:
    - `GET /users/stats`;
    - `GET /pullRequests/stats`.

Результаты:

- всего HTTP-запросов: **10 900** (~**362 req/s**);
- средняя латентность (`http_req_duration avg`): **≈ 4.9 ms**;
- медиана (`med`): **≈ 5.2 ms**;
- 90-й перцентиль (`p(90)`): **≈ 7.6 ms**;
- 95-й перцентиль (`p(95)`): **≈ 8.5 ms**;
- ошибок (`http_req_failed`): **0 %**;
- все проверки статуса ответа (200) успешно прошли (`checks_succeeded = 100 %`).

Вывод: оба эндпоинта статистики стабильно выдерживают ~360 запросов в секунду с задержками < 10 ms без ошибок.

<img width="1033" height="770" alt="image" src="https://github.com/user-attachments/assets/c0547c8f-d9e0-403e-81c3-2748441d38b5" />

---

### Запись (создание PR)

Сценарий (`load_write.js`):

- 10 виртуальных пользователей (`vus = 10`);
- длительность теста — 30 секунд;
- каждый VU в цикле отправляет `POST /pullRequest/create` с уникальными
  `pull_request_id` и `pull_request_name` и фиксированными `author_id`.

Пример тела запроса:

```json
{
  "pull_request_id": "k6-pr-<VU>-<timestamp>",
  "pull_request_name": "k6-load-<VU>-<timestamp>",
  "author_id": "u1"
}
```
Результаты:
- всего HTTP-запросов: **2 800** (~**93 req/s**);
- средняя латентность (`http_req_duration avg`): **≈ 6.9 ms**;
- медиана (`med`): **≈ 6.2 ms**;
- 90-й перцентиль (`p(90)`): **≈ 8.5 ms**;
- 95-й перцентиль (`p(95)`): **≈ 9.5 ms**;
- ошибок (`http_req_failed`): **0 %**;
- все проверки статуса ответа (201/200) успешно прошли (`checks_succeeded = 100 %`).

Вывод: при нагрузке ~90 запросов/секунду на создание PR сервис отвечает за ~7–10 ms и не даёт ошибок.

<img width="995" height="747" alt="image" src="https://github.com/user-attachments/assets/044a5eea-6814-4696-848d-2ca56b8ca44f" />

## Интеграционный тест (E2E)

Для интеграционного тестирования используется отдельный экземпляр Postgres (`db_test`) из `docker-compose.yml`
и отдельная база `avito_test`.

Сценарий E2E-теста `TestE2E_CreatePRAndStats`:
- поднимается HTTP-сервер с тестовой БД;
- через публичные HTTP-эндпоинты последовательно выполняются шаги:
    - `POST /team/add` — создание команды `backend` с двумя пользователями (`u1`, `u2`);
    - `POST /pullRequest/create` — создание PR `pr-e2e-1` от пользователя `u1`;
    - `GET /users/stats` — проверка, что пользователь `u2` фигурирует как ревьюер с `assignments = 1`;
    - `GET /pullRequests/stats` — проверка, что для `pr-e2e-1` количество ревьюеров равно `1`.

Запуск в Makefile:

```bash
make test-e2e
```
Команда делает следующее:

- поднимает контейнер `db_test` с PostgreSQL на порту `5433`;
- применяет SQL-миграции из каталога `migrations/` к базе `avito_test`;
- запускает тесты с build-тегом `integration` в пакете `test/e2e`;
- после выполнения тестов останавливает контейнер `db_test`.

## Принятые решения и допущения

- **Порт в OpenAPI** — в `openapi.yml` сервер выставлен на `http://localhost:8080`, чтобы совпадать с реальным `HTTP_ADDR` и корректно тестироваться через OpenAPI.
- **Поле в `/pullRequest/reassign`** — в исходном примере в OpenAPI в запросе использовалось `old_reviewer_id`, а в требованиях `old_user_id`. Для соответствия коду и корректного JSON-декодинга свёл всё к `old_user_id`.
- **Admin token для `/users/setIsActive`** — в OpenAPI он присутствует, но в самом ТЗ никак не описан (нет требований, где брать токен, как его передавать и кого считать админом), поэтому я осознанно не реализовывал эту часть.
- **Пустые команды** — в ТЗ не было описано, что делать при создании команды без участников, поэтому я принял решение разрешить такой кейс: команда может быть создана с пустым списком участников (считаю это естественным сценарием).
- **Ограничение по командам** — в ТЗ не было указано, может ли один пользователь состоять в нескольких командах, поэтому я принял решение ограничить пользователя одной командой: при попытке добавить его в другую возвращается `VALIDATION_ERROR`. Это упрощает модель и делает выбор ревьюеров однозначным.
- **Для статистических эндпоинтов** `/users/stats` и `/pullRequests/stats` принято следующее поведение:
    - эндпоинты возвращают HTTP 200 и объект с полем `items` (список может быть пустым — это не считается ошибкой);
    - `/users/stats` возвращает всех пользователей из таблицы `users`, даже если они ни разу не были ревьюером
      (в этом случае `assignments = 0`);
    - `/pullRequests/stats` возвращает все pull request’ы из таблицы `pull_requests`,
      даже если на них не назначено ни одного ревьюера (в этом случае `reviewers = 0`).

